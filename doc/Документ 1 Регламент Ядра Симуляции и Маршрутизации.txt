Регламент разработки MMO-сервера (Single-World Hex)
1) Цель и границы
Один логический мир. Ключ маршрутизации: hex_id (гекс = узел/нода мира).

Масштабируемая симуляция без «копий серверов». Доменные сервисы вынесены отдельно.

Клиент авторитарный сервером; сеть — WebSocket.

2) Термины
Gateway — входной слой (WS/HTTP): аутентификация, rate-limit, идемпотентность.

Router — stateless-маршрутизатор по hex_id (и опц. layer_id) на воркеры.

Worker — процесс симуляции; хостит множество акторов.

Actor (cell/hex) — объект с собственным состоянием и mailbox; единственный писатель данных конкретного hex_id.

Domain service — инвентарь/рынок/чат и т.п. (вне тика симуляции).

3) Архитектурные принципы
Single-writer per key: всё состояние гекса меняет только его актор.

Очередность по ключу: события одного hex_id обрабатываются строго последовательно.

Общение только сообщениями: без прямых RPC между акторами/сервисами.

PG = источник истины, Mongo = снапшоты/read-модель мира.

Идемпотентность везде: повторы безопасны.

4) Транспорт и маршрутизация
Брокер: RabbitMQ (или NATS JetStream).

Exchange cmd.direct; P партиций очередей cmd.p0..p{P-1}.

partition = hash(hex_id) % P; один consumer на партицию; prefetch=1.

Router хранит только соответствие «партиция→воркер» (leases), не исполняет логику.

5) Контракт сообщения (envelope)
Поля обязательны:

type (cmd.* / evt.*), version

key (hex_id, опц. layer_id)

request_id, event_id (UUID), causation_id, correlation_id

producer (сервис/версия), ts

idempotency_key (для команд)

payload (строго по схеме)
Правило: изменения схем — назад-совместимые; поле version инкрементируется.

6) Актор (контракт)
Жизненный цикл: on_start(load_snapshot) → handle(msg)* → snapshot_periodic.

Один runner на актор, одна локальная очередь (mailbox).

Разрешено: изменять только «свои» документы/ключи, эмитить события, делать снапшоты.

Запрещено: мутировать чужие hex_id, держать shared-state между акторами.

Handoff игрока между гексами — через сообщение transfer.

7) Состояние и запись
Mongo (world.hex_state): документ на hex_id с version, updated_at, гейм-полями (level, xp, owner, …). Upsert только из актора.

PostgreSQL: аккаунты, инвентарь, экономические транзакции, репутация, журналы вкладов/голосований.

Outbox в PG (или CDC) для доставки изменений в read-модели/события.

Снапшот-политика: каждые N применённых событий или T секунд (что раньше).

8) Домены (вне тика)
Inventory/Market/Chat — отдельные сервисы, отдельные схемы БД, свои очереди.

Коммуникация с симуляцией только сообщениями (evt.* / cmd.*), без прямых SQL к «чужим» данным.

9) Отказоустойчивость и оркестрация
Registry/leases (Redis/PG): lease:cmd.p{N} → worker_id, TTL + heartbeat.

Фейловер: при истечении lease партиция перепривязывается к другому воркеру; акторы поднимаются из снапшота.

Пин «горячих» гексов: pin:hex:{hex_id} → worker_id (опционально).

10) Ошибки и ретраи
Доставка at-least-once.

Дедупликация по event_id/idempotency_key.

Poison/DLQ для сообщений, не прошедших N ретраев.

Команды, нарушающие инварианты, возвращают детерминированные ошибки (error_code, reason, retry_after?).

11) Наблюдаемость
Логи: корреляция по request_id, event_id, ключ-поля (hex_id).

Метрики (минимум): длина очередей, TPS по hex_id, p95 времени обработки актора, частота снапшотов, % ретраев/DLQ.

Трейсинг: Gateway→Router→Worker→Actor→… (distributed tracing).

12) Версионирование/миграции
DB: Alembic (PG), скрипты индексов (Mongo).

Сообщения: семантика backward-compatible; потребители обязаны игнорировать неизвестные поля.

Роллинг-деплой: сначала потребители (понимают новую схему), потом продюсеры.

13) Безопасность/доступ
Сервисные аккаунты с минимальными правами; отдельные схемы в PG; RLS по необходимости.

NetworkPolicy/ACL между сервисами.

Валидация payload на входе (Gateway) и перед записью (Actor/Domain).

14) Репозиторий/код-стайл
pgsql
Копировать
Редактировать
/apps/{gateway,router,sim-worker,inventory-svc,market-svc,chat-svc}
/libs/{messaging,domain,utils}
/infra/{pg_migrations,mongo_indices}
/deploy/{docker,k8s}
/config/{base,dev,prod}.yaml
Pydantic-схемы в /libs/messaging.

Один источник типов/констант в /libs/domain.

Линт: black/ruff/mypy. Коммиты: Conventional Commits.

15) Тестирование
Unit хендлеров акторов (детерминизм, идемпотентность).

Contract-тесты сообщений (схема/совместимость).

Интеграционные: flow Gateway→Actor→Mongo/PG.

Нагрузочные: p95 актора, DLQ-поведение.

Мини-параметры по умолчанию (если не указано иное)
Партиций P: 8…64 (≥ кол-ва воркеров).

Снапшот: каждые 5–10 событий или 10 сек.

Идемпотентность: idempotency_key = sha256(client_id|request_id|type|key).

Retrires: max 5 с экспоненциальным backoff, затем DLQ.

H3-масштаб: res=5 (~10 км) или res=6 (~5 км) — выбрать один и зафиксировать.

Если хочешь, создам такой документ в канвасе как «Проектный регламент v1» и (по желанию) добавлю туда конкретные значения T0, r, N_max(L), K(L) для твоего геймплея.