# Версионирование контрактов

## 1. Основной принцип

Для обеспечения обратной совместимости и плавного развёртывания новых версий сервисов, все "публичные" контракты (имена очередей, событий, ключи маршрутизации) явно версионируются.

-   **Формат**: Суффикс `.vN` добавляется в конец имени, где `N` — номер версии.
-   **Пример**: `core.auth.rpc.issue_token.v1`

## 2. Когда нужно повышать версию?

Версия контракта повышается только при **несовместимых изменениях (breaking changes)**.

### Примеры несовместимых изменений:

-   Удаление поля из DTO.
-   Переименование поля в DTO.
-   Изменение типа данных поля (например, `string` -> `integer`).
-   Изменение фундаментальной логики, которую старые клиенты не смогут обработать.

### Примеры совместимых изменений (версию повышать НЕ нужно):

-   Добавление нового опционального поля в DTO.
-   Добавление нового значения в `Enum`.
-   Исправление бага без изменения контракта.

## 3. Процесс обновления на новую версию (например, с `v1` на `v2`)

1.  **Развёртывание потребителей (`Consumers`)**:
    -   Сначала разворачиваются новые версии сервисов-потребителей, которые умеют обрабатывать **обе версии** контракта (`v1` и `v2`).
    -   Например, `gateway` должен уметь вызывать `...issue_token.v2`, но быть готовым к тому, что сервис `auth_svc` ещё старой версии.

2.  **Развёртывание производителей (`Producers`)**:
    -   Разворачивается новая версия сервиса-производителя (`auth_svc`), которая начинает слушать новую очередь `...issue_token.v2`.
    -   В течение переходного периода старая версия сервиса продолжает обрабатывать сообщения из очереди `v1`.

3.  **Переключение клиентов**:
    -   Клиенты (или сервисы-вызывающие) переводятся на использование нового контракта `v2`.

4.  **Вывод из эксплуатации старой версии (`Deprecation`)**:
    -   После того как весь трафик перешёл на `v2`, код, обрабатывающий `v1`, и сама очередь `v1` могут быть удалены.
    -   Устанавливается период "депрекации", после которого старый эндпоинт/очередь гарантированно отключаются.