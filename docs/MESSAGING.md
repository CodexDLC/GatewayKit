# Обмен сообщениями (RabbitMQ)

## 1. Именование

### Exchanges
| Имя | Тип | Назначение |
|---|---|---|
| `core.rpc.v1` | direct | Для всех RPC-вызовов. |
| `core.events.v1`| topic | Для доменных событий (публикация-подписка). |
| `core.dlx.v1` | direct | Dead-Letter Exchange для маршрутизации "мертвых" и retry-сообщений. |

### Очереди
Для каждого RPC-метода (например, `core.auth.rpc.issue_token.v1`) создается 3 очереди:
-   **Основная:** `core.auth.rpc.issue_token.v1` — здесь обрабатываются входящие запросы.
-   **Retry-очередь:** `core.auth.rpc.issue_token.v1.retry` — сюда попадают сообщения после временной ошибки. Имеет TTL.
-   **DLQ:** `core.auth.rpc.issue_token.v1.dlq` — "кладбище" сообщений после превышения всех попыток.

---

## 2. Схема Retry / Dead Letter Queue (DLQ)

Для обеспечения надежности каждый RPC-обработчик использует схему с повторными попытками и очередью для неисправимых ошибок.

1.  **Успех:** Сообщение обрабатывается и подтверждается (`ack`).
2.  **Временная ошибка** (например, недоступность БД): Обработчик отвечает `nack(requeue=false)`. Сообщение попадает в `core.dlx.v1` и маршрутизируется в **retry-очередь**.
3.  В **retry-очереди** сообщение "ждет" `RPC_RETRY_DELAY_MS` миллисекунд (из-за TTL), после чего автоматически возвращается в основную очередь для повторной обработки.
4.  **Превышение лимита ретраев:** Если сообщение превысило `RPC_MAX_RETRIES` попыток, обработчик отправляет его в `core.dlx.v1` с ключом маршрутизации, ведущим в **DLQ**.
5.  **Нерепарибельная ошибка** (например, ошибка валидации): Сообщение сразу отправляется в **DLQ**.

---

## 3. RPC-контракт

Все RPC-вызовы следуют единому формату ответа.

### Структура `RpcResponse`
```json
{
  "success": true,
  "data": { /* Полезная нагрузка */ },
  "error_code": null,
  "message": null,
  "correlation_id": "req_a1b2c3d4"
}