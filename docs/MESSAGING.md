# Обмен сообщениями (RabbitMQ)

## 1. Именование

### Exchanges
| Имя | Тип | Назначение |
|---|---|---|
| `core.rpc.v1` | direct | Для всех RPC-вызовов. |
| `core.events.v1`| topic | Для доменных событий. |
| `core.dlx.v1` | direct | Dead-Letter Exchange для Retry/DLQ. |

### Очереди RPC (Auth Service)
* `core.auth.rpc.register.v1`
* `core.auth.rpc.issue_token.v1`
* `core.auth.rpc.validate_token.v1`
* `core.auth.rpc.refresh_token.v1`
* `core.auth.rpc.logout.v1`

---

## 2. Схема Retry / Dead Letter Queue (DLQ)

Для обеспечения надежности каждый RPC-обработчик использует схему с повторными попытками и очередью для неисправимых ошибок.

1.  **Успех:** Сообщение обрабатывается и подтверждается (`ack`).
2.  **Временная ошибка** (например, недоступность БД): Обработчик отвечает `nack(requeue=false)`. Сообщение попадает в `core.dlx.v1` и маршрутизируется в **retry-очередь**.
3.  В **retry-очереди** сообщение "ждет" `RPC_RETRY_DELAY_MS` миллисекунд (из-за TTL), после чего автоматически возвращается в основную очередь для повторной обработки.
4.  **Превышение лимита ретраев:** Если сообщение превысило `RPC_MAX_RETRIES` попыток, обработчик отправляет его в `core.dlx.v1` с ключом маршрутизации, ведущим в **DLQ**.
5.  **Нерепарибельная ошибка** (например, ошибка валидации): Сообщение сразу отправляется в **DLQ**.

---

## 3. RPC-контракт

Все RPC-вызовы следуют единому формату ответа.

### Структура `RpcResponse`
```json
{
  "success": true,
  "data": { /* Полезная нагрузка */ },
  "error_code": null,
  "message": null,
  "correlation_id": "req_a1b2c3d4"
}