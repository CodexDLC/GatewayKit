# План по масштабированию и производительности

Этот документ описывает будущие шаги по обеспечению высокой производительности и масштабируемости сервиса. Эти задачи рекомендуется выполнять на этапе подготовки к production-нагрузкам.

## 1. Архитектура масштабирования

* **RPC (auth_svc)**: Масштабируется горизонтально путем добавления новых экземпляров сервиса `auth_svc`. Каждый экземпляр становится потребителем в общей RPC-очереди, что позволяет распределять нагрузку.
* **WebSocket (gateway)**: Масштабируется горизонтально путем добавления новых экземпляров `gateway`. Каждый экземпляр подписывается своей временной (ephemeral) очередью на общую шину событий, что позволяет каждому шлюзу получать все широковещательные сообщения и доставлять их своим клиентам.
* **Состояние WS**: На начальном этапе состояние соединений хранится в памяти каждого экземпляра `gateway`. Для отказоустойчивости и синхронизации статуса "онлайн" используется Redis.

## 2. Тюнинги и лимиты через ENV

Для гибкой настройки производительности без изменения кода следует вынести следующие параметры в переменные окружения.

#### RabbitMQ/RPC
* `RPC_TIMEOUT_MS`: Таймаут ожидания RPC-ответа (например, `5000`).
* `RPC_RETRY_DELAYS_MS`: Задержки между повторными попытками, например `"1000,5000,30000"` (экспоненциальная выдержка).
* `RPC_MAX_RETRIES`: Максимальное количество ретраев (например, `3`).
* `RPC_CONSUMER_PREFETCH`: Количество сообщений, которые потребитель может взять из очереди за раз (например, `32`).

#### Gateway (HTTP/WS)
* `GUNICORN_WORKERS`: Количество Gunicorn-воркеров (например, `2`).
* `GATEWAY_WS_MAX_OUTBOX`: Лимит очереди исходящих сообщений на одно WS-соединение (например, `100`). При переполнении соединение закрывается для предотвращения лавины.

#### PostgreSQL (auth_svc)
* `PG_POOL_SIZE`: Размер пула соединений SQLAlchemy (например, `10`).
* `PG_MAX_OVERFLOW`: Количество дополнительных соединений сверх пула (например, `5`).
* `PG_STATEMENT_TIMEOUT_MS`: Таймаут на выполнение любого SQL-запроса (например, `2000`).
* `PG_IDLE_IN_TX_TIMEOUT_MS`: Таймаут для простаивающих транзакций (например, `5000`).

## 3. Нагрузочное тестирование

Для проверки системы под нагрузкой необходимо разработать скрипты (например, на k6 или Locust).

#### Сценарии для тестов:
1.  **Стабильный поток RPC**: Эмуляция большого количества одновременных логинов (`issue_token`) для проверки стабильности `auth_svc`.
2.  **Обработка таймаутов RPC**: Искусственное замедление обработчика для проверки корректной работы механизма ретраев и DLQ.
3.  **Массовые подключения WebSocket**: Эмуляция подключения большого количества клиентов к `gateway` и проверка стабильности доставки широковещательных сообщений.

## 4. Наблюдаемость (Observability)

Для анализа производительности необходимо расширить логирование, добавив метрики:
* **RPC**: `latency_ms`, `retry_count`, `result_status` (ok/error/timeout).
* **Consumers**: Агрегированные метрики `acks/s`, `nacks/s`, `inflight_messages`.
* **Gateway**: `online_ws_clients`, `broadcast_queue_length`.

## 5. Процедуры защиты
* **Анти-лавина RPC**: Использовать `publisher-confirms` и `mandatory` флаги в RabbitMQ для контроля над тем, что сообщения доходят до очередей. Внедрить механизм "быстрого отказа" (circuit breaker) на шлюзе при перегрузке RPC-сервисов.
* **Анти-затык WS**: При переполнении исходящего буфера (`GATEWAY_WS_MAX_OUTBOX`) принудительно закрывать "медленные" соединения, чтобы они не влияли на остальных.
* **Анти-утечки БД**: Использовать таймауты на уровне сессий PostgreSQL для предотвращения "зависших" транзакций.