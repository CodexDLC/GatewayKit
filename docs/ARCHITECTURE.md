# Архитектура проекта

## 1. Основные принципы

Проект построен на принципах микросервисной архитектуры с асинхронным обменом сообщениями через брокер RabbitMQ.

* **"Тонкие" приложения (`apps`) / "Толстые" библиотеки (`libs`)**: Вся основная бизнес-логика, доменные модели (DTO, ORM), инфраструктурный код и утилиты находятся в `libs`. Приложения в `apps` являются тонкими слоями, которые отвечают только за запуск и конфигурацию сервиса.

* **DI-контейнер**: Зависимости для каждого сервиса (подключения к БД, RabbitMQ) управляются через **специализированные DI-контейнеры** в `libs/containers/`. Они инициализируются при старте каждого сервиса.

* **Единый Bootstrap**: Все сервисы инициализируются и запускаются по единому шаблону с помощью фабрики `create_service_app` из `libs/app/bootstrap.py`.

## 2. Схема взаимодействия сервисов

                               +------------------+
                             / |     RabbitMQ     |
      (RPC-запросы/События) /  | (Брокер сообщений) |
                           /   +------------------+
+-----------+      +-------------------+      ^            +--------------------+
|  Клиенты  |----->|      Gateway      |---- /             |      Auth SVC      |
| (WS/HTTP) |      | (REST API / WS)   |                  | (RPC-сервис, JWT)  |
+-----------+      +-------------------+                  +--------------------+
                                                                     |
                                                                     v
                                                          +--------------------+
                                                          |     PostgreSQL     |
                                                          | (Схема 'auth')     |
                                                          +--------------------+

1.  **Gateway**: Единственная точка входа для клиентов. Отвечает за:
    * Прием HTTP и WebSocket запросов.
    * **Проксирование** запросов аутентификации в `Auth SVC` через RPC.
    * **Авторизацию** всех входящих запросов (проверка JWT).
    * Трансляцию событий из RabbitMQ клиентам по WebSocket.

2.  **RabbitMQ**: Центральный брокер для асинхронного взаимодействия.

3.  **Auth SVC**: Сервис аутентификации. Отвечает за:
    * Регистрацию, вход, выход, обновление токенов.
    * Работу с базой данных (таблицы `accounts`, `credentials`, `refresh_tokens`).
    * Выпуск и валидацию JWT.

4.  **PostgreSQL**: Основное хранилище данных для `auth_svc`.

## 3. Процесс запуска сервиса (Bootstrap Flow)

Все сервисы запускаются по единой, четко определенной последовательности, управляемой модулем `libs/app/bootstrap.py`.

1.  **Вызов `create_service_app`**: В файле `..._main.py` каждого сервиса вызывается фабрика `create_service_app`, которой передается вся необходимая конфигурация (имя, DI-контейнер, слушатели, роуты).

2.  **Создание FastAPI-приложения**: Фабрика создает экземпляр `FastAPI`.

3.  **Загрузка настроек**: Если передан `settings_class`, создается его экземпляр. Pydantic автоматически загружает переменные из `.env`.

4.  **Старт `lifespan`**: Приложение запускается, активируя менеджер жизненного цикла `service_lifespan`.

5.  **Инициализация DI-контейнера**: Вызывается `container_factory` (например, `AuthContainer.create`), который создает и инициализирует все зависимости:
    * Устанавливает соединения с RabbitMQ.
    * Устанавливает соединения с Redis.
    * Готовит фабрику сессий для PostgreSQL.

6.  **Объявление топологии RabbitMQ**: Вызывается `topology_declarator`, который создает все необходимые `exchanges` и `queues`.

7.  **Запуск слушателей**: Создаются и запускаются все фоновые слушатели (например, RPC-обработчики).

8.  **Сервис готов**: Приложение полностью готово к приему трафика.

9.  **Корректное завершение (Graceful Shutdown)**: При получении сигнала остановки `lifespan` выполняет обратную последовательность: останавливает слушателей и закрывает все соединения в DI-контейнере.